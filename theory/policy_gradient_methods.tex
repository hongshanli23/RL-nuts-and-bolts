\documentclass{article}
\usepackage{macro}
\usepackage{graphicx}
\graphicspath{ {./} }
\title{Policy Gradient Methods for Deep Reinforcement Learning}
\author{Hongshan Li(hongshal@amazon.com)}
\begin{document}
\maketitle

RL is big and rich, its history traces back to Pavlov's study on the 
psychology of animal learning (conditional response) back in 1902.
The expository article History of Reinforcement Learning (http://incompleteideas.net/book/first/ebook/node12.html) is a good resource to learn
how RL evolved in the last 100 years.

Policy Gradient Methods is a class of RL algorithms that directly 
learns a policy from interaction with the environment. In contrast,
to this, one can also learn a state value estimate of the current
state of the env and the candidate actions. This class of algorithms
is called Q-learning. 


\textbf{Review about setups in RL}
The objective of RL is to find a policy $\pi$ that gets the highest 
rewards from a \emph{Markov Decision Process}

\includegraphics[width=8cm]{mdp}

At time step $t$, the env is at state $S_t$, the agent takes action 
$A_t$, the env transition into $S_{t+1}$ and the agent receives a 
reward of $R_{t+1}$. 

The critical assumption of MPD is
\begin{itemize}
    \item The transition probability $P(S_{t+1}, R_{t+1}|S_t, A_t)$ is
        independent from the history
    \item The agent's action does not alter the transition probability,
        i.e. $P(S_{t+1}, R_{t+1} | S_t, A_t)$ is the same whenver 
        the agent sees $S_t$ and takes action $A_t$
\end{itemize}

The transition probability $P(S_{t+1}, R_{t+1} | S_t, A_t)$ is call 
the \emph{model} of the env. The objective of RL is to find a
\emph{optimal policy}
(what action to take at $S_t$) that maximize the total reward

If $P(S_{t+1}, R_{t+1}|S_t, A_t) = 1$ for all $S$ and $A$, then we say
the env is deterministic, otherwise stochastic.

The total reward from time $t$ is 
\[
    G_t = R_{t+1} + R_{t+2} + \cdots + R_{T}
\]
The MDP terminates at $T$. 

To prioritize short term return over long term return, we use a 
discount factor $\gamma \in [0, 1]$ and define
\[
    G_t = R_{t+1} + \gamma R_{t+2} + \gamma^2 R_{t+3} + \cdots 
    + \gamma^k R_{t+k+1} + \cdots + \gamma^{T-t-1}R_{T}
\]

A few ways to think about the discount factor
\begin{itemize}
    \item prioritize short term reward
    \item A mathematical convenience for infinite episodic task; we 
        want $G_t$ to be a finite number even if the MDP never stops.
        \[
            \sum_{i=0}^{\infty} \gamma^i = \frac{1}{1-\gamma}
        \]
        so 
        \[
            G_t \le \frac{1}{1-\gamma} * R_{\max}
        \]
    \item a way to factor in the probability that agent dies. The agent 
        survives with prob $\gamma$ and die with prob $1 - \gamma$.
        i.e reward at time $t$ is 
        \[
            \gamma R_{t+1} + (1 - \gamma) * 0
        \]
\end{itemize}

Let $\mathscr{S}$ be the state space, and $\mathscr{A}$ the action space.
A \emph{deterministic policy} is a mapping 
\[
    \pi: \mathbb{S} \rightarrow \mathbb{A}
\]
and a \emph{stochastic} policy is a mapping
\[
    \pi: \mathbb{S} \rightarrow Dist( \mathbb{A} )
\]
where $Dist(\mathscr{ A })$ denote the space of probability distributions
over the action spaces.

Both deterministc env and determinsitc policy are special cases of their
stochastic counterparts.(all probability concentrate at 1 point). So 
we only address the stochastic cases in the rest of the note.

Suppose the agent's current policy is $\pi$, then at state $S_t$
$\pi$ yields a probability distribution over the action space
\[
    \pi(\cdot | S_t)
\]
from which the agent samples actions. 

So with the model of the env, we can write down the expected total 
reward if we follow the policy $\pi$. Assume the initial state is $s$
\begin{align}
    v_{\pi}(s) & \definedas \E_{\tau \sim \pi}[G_0 | S_0 = s] \\
        & \E_{\tau sim \pi}(R_1 + \gamma v_{\pi}(s^{\prime}) 
\end{align}
$s^{\prime}$ denotes the next state of the env.
$\tau$ denotes a trajectory sampled from the policy $\pi$.


We can use Monte Carlo method to estimate $v_{\pi}(s)$ by running the 
policy a couple of times and compute the average return $G_0$. 


\textbf{Policy Iteration} How do we improve the policy? That's all RL is 
about. In supervised learning, the objective is to find a parametric
model $p_{\theta}$ that maximize the likelihood of the input dataset;
in RL, the objective is to train a policy that gets the highest reward
from the env. 

A fundamental difference supervised learning and RL is that data is 
completely determined before any training, whereas in RL data is
dynamically generated through interaction with the environment. 
This means the distribution of the data for SL is static and the 
distribution of data for RL changes as the agent learns. 

Suppose we have a value function $v_{\pi}$ for the current policy $\pi$,
one naive way to improve $\pi$ is to "look ahead one step of time". 
At $t$, we are at $S_t=s$, the policy results an action $\pi(s)$, 
we want whether it 
is a good idea to choose a different action $a \neq \pi(s)$? We can simply
take $a$ and follow $\pi$ afterwards. This is defined as the state-action
value 
\[
    q_{\pi}(s, a) = \E[R_{t+1} + \gamma v_{\pi}(S_{t+1}) | S_t=s, A_t=a]
\]

Recall
\[
    v_{\pi}(s) = \E[R_{t+1} + \gamma v_{\pi}(S_{t+1}) | S_t=s, A_t=\pi(s)]
\]
If $q_{\pi}(s, a) - v_{\pi}(s) > 0$, then it is a good idea to assume 
action $a$ at $s$. 

This gives us a template for generalized policy iteration

\begin{algorithm}[H]
    \caption{Generalized Policy Iteration}
\end{algorithm}

\begin{algorithmic}
    \STATE Input: initial policy $\pi$
    \REPEAT
    \STATE evaluate the policy $\pi$ and get $v_{\pi}$
    \FOR{each $s \in \mathbb{S}$}
    \STATE $old_action\leftarrow \pi(s)$
    \STATE $\pi(s) \leftarrow \argmax_a \E[r + \gamma v(s^{\prime})$
    \ENDFOR
    \UNTIL{$\pi$ stops improving}
\end{algorithmic}

\section{Function Approximation and Policy Gradient Methods}
The above generalized policy iteration works pretty well if the underlying
MPD is finite (finitely states). One gets $v_{\pi}$ by dynamic programing.
But this becomes intractable if the state space is big. Suppose your 
state is given as a 2D image with dimension 512x512, then your state
space is of size $(3x515x512)^{256} \sim 1.5x10^{1510}$. 

Function approximation is the idea that addresses the curse of dimension
problem when the state space gets big (or even infinite). The idea is 
if two states are "similiar" the agent should take the similar actions 
and the value of that states should be similar as well. So we can use
parametrized functions $v_{\theta}$ and $\pi_{\theta}$ to represents 
the value and policy tables. The differentiabilities of $v_{\theta}$ 
and $\pi_{\theta}$ ensures that similar states have similar value and 
the agent acts similarly. 

Now we are officially in the Deep Reinforcement Learning (DRL) world. 
\textbf{Policy gradient methods} concerns about the following question:
How do we move the parameters of $\pi_{\theta}$ so that $\pi_{\theta}$
improves. "Move" in this context means updating $\theta$ according to 
the \emph{policy gradient}. 

In tabular method, we have defined the value of a policy. Analogous 
definition carries over
\[
    J(\theta) = v_{\pi_{\theta}}(s)
\]
To improve $J(\theta)$, we do the usual calculus trick (gradient ascend)
\[
    \theta \leftarrow \theta + \alpha \nabla J(\theta)
\]
This is basically the entirty of policy gradient methods.

So the next thing is how to compute $\nabla J(\theta)$ 


\begin{theorem}[Policy Gradient Theorem]
Suppose the state space $\mathbb{S}$ and action space $\mathbb{A}$ 
are discrete
\[
    \nabla J(\theta) \propto \sum_{s}\mu(s)\sum_{a} 
    \nabla \pi(a|s)q_{\pi}(s, a)
\]
where $\mu(s)$ is the \emph{visition} frequency (how often the 
agent visits state $s$

If $\mathbb{S}$ and $\mathbb{A}$ are continuous
\[
    \nabla J(\theta) \propto \int_{\mathbb{S}}\mu(s)\int_{\mathbb{A}} 
    \nabla\pi(a|s)q_{\pi}(s, a) dsda
\]
\end{theorem}



Talk about value iteration and policy iteration;
Talk about how tabular methods can be used to achieve
value/policy iteration;
Talk about why tabular method is not sufficient and function 
approximator;

then talk about parametrized policy and policy gradient theorem 



\textbf{REINFOCE}



% \biblio
History of Reinforcement Learning
http://incompleteideas.net/book/first/ebook/node12.html
\end{document}

